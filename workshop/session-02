# Run the first node and keep it in background up and running
docker run --name cassandra-1 -p 9042:9042 -d cassandra:5.0.3
INSTANCE1=$(docker inspect --format="{{ .NetworkSettings.IPAddress }}" cassandra-1)
echo "Instance 1: ${INSTANCE1}"

# Run the second node
docker run --name cassandra-2 -p 9043:9042 -d -e CASSANDRA_SEEDS=$INSTANCE1 cassandra:5.0.3
INSTANCE2=$(docker inspect --format="{{ .NetworkSettings.IPAddress }}" cassandra-2)
echo "Instance 2: ${INSTANCE2}"

echo "Wait 60s until the second node joins the cluster"
sleep 60

# Run the third node
docker run --name cassandra-3 -p 9044:9042 -d -e CASSANDRA_SEEDS=$INSTANCE1,$INSTANCE2 cassandra:5.0.3
INSTANCE3=$(docker inspect --format="{{ .NetworkSettings.IPAddress }}" cassandra-3)



$ docker exec cassandra-1 nodetool status

UN means Up and Normal


$ docker exec -it cassandra-1 cqlsh


# show all existing keyspaces 

cqlsh> describe keyspaces


# Before you begin creating tables and inserting data, first create a keyspace in your local datacenter, 
# which should replicate data 3 times

# The strategy defines how data is replicated in different datacenters. 
# This is the recommended strategy for all user created keyspaces.

cqlsh> CREATE KEYSPACE learn_cassandra
  WITH REPLICATION = { 
   'class' : 'NetworkTopologyStrategy',
   'datacenter1' : 3 
  };


# Why should you start with 3 nodes?
# It’s recommended to have at least 3 nodes or more. One reason is, in case you need strong consistency, 
# you need to get confirmed data from at least 2 nodes. Or if 1 node goes down, 
# your cluster would still be available because the 2 remaining nodes are up and running.


Cassandra Architecture

    Cassandra is a decentralized multi-node database that physically spans separate locations 
    and uses replication and partitioning to infinitely scale reads and writes.

Decentralization
    Cassandra is decentralized because no node is superior to other nodes, 
    and every node acts in different roles as needed without any central controller.

Every Node Is a Coordinator
    Data is replicated to different nodes. If certain data is requested, 
    a request can be processed from any node.

    This initial request receiver becomes the coordinator node for that request. 
    If other nodes need to be checked to ensure consistency then the 
    coordinator requests the required data from replica nodes.

    The coordinator can calculate which node contains 
    the data using a so-called consistent hashing algorithm.

    The coordinator is responsible for many things, 
    such as request batching, repairing data, or retries for reads and writes.

Data Partitioning
    “[Partitioning] is a method of splitting and storing a single logical dataset 
    in multiple databases. By distributing the data among multiple machines, 
    a cluster of database systems can store larger datasets 
    and handle additional requests.

    As with many other databases, you store data in Cassandra in a predefined schema. 
    You need to define a table with columns and types for each column.

    Additionally, you need to think about the primary key of your table. 
    A primary key is mandatory and ensures data is uniquely identifiable 
    by one or multiple columns.

    The concept of primary keys is more complex in Cassandra than in 
    traditional databases like MySQL. 
    
    In Cassandra, the primary key consists of 2 parts:

        1. a mandatory partition key
        2. an optional set of clustering columns


cqlsh> CREATE TABLE learn_cassandra.users_by_country (
    country text,
    user_email text,
    first_name text,
    last_name text,
    age smallint,
    PRIMARY KEY ((country), user_email)
);

Let’s fill the table with some data:

------------------------------------------------------

cqlsh> 
INSERT INTO learn_cassandra.users_by_country (country,user_email,first_name,last_name,age)
  VALUES('US', 'john@email.com', 'John','Wick',55);

INSERT INTO learn_cassandra.users_by_country (country,user_email,first_name,last_name,age)
  VALUES('UK', 'peter@email.com', 'Peter','Clark',65);

INSERT INTO learn_cassandra.users_by_country (country,user_email,first_name,last_name,age)
  VALUES('UK', 'bob@email.com', 'Bob','Sandler',23);

INSERT INTO learn_cassandra.users_by_country (country,user_email,first_name,last_name,age)
  VALUES('UK', 'alice@email.com', 'Alice','Brown',26);

------------------------------------------------------

    If you’re used to designing traditional relational database tables 
    like it’s taught in school or university, you might be surprised. 
    Why would you use country as an essential part of the primary key?

    This example will make sense after you understand 
    the basics of partitioning in Cassandra.

    Partitioning is the foundation for scalability, 
    and it is based on the partition key. In this example, 
    partitions are created based on country. 
    All rows with the country US are placed in a partition. 
    All other rows with the country UK will be stored in another partition.

    The partition key is vital to distribute data evenly between nodes 
    and essential when reading the data. The previously defined schema 
    is designed to be queried by country because country is the partition key.

    A query that selects rows by country performs well:
    
    ------------------------------------------------------
    cqlsh> 
        SELECT * FROM learn_cassandra.users_by_country WHERE country='US';
    ------------------------------------------------------



https://www.freecodecamp.org/news/the-apache-cassandra-beginner-tutorial/

https://madhuramehendale.medium.com/partition-key-in-cassandra-f36d8670375c