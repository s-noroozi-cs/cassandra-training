UPDATEs Are Just INSERTs, and Vice Versa

    In Cassandra, everything is append-only. There is no difference between an update and insert.

    You already learned that a primary key defines the uniqueness of a row. 
    If there is no entry yet, a new row will appear, and if there is already an entry, 
    the entry will be updated. It does not matter if you execute an update or insert a query.

    The primary key in our example is set to user_email and creation_date that defines record uniqueness.

    Let’s insert a new record:

    cqlsh>      
        INSERT INTO learn_cassandra.todo_by_user_email (user_email, creation_date, name) 
        VALUES('john@email.com', '2021-03-14 16:07:19.622+0000', 'Insert query');

    And execute an update with a new todo_uuid:

    cqlsh>    
        UPDATE learn_cassandra.todo_by_user_email SET 
            name = 'Update query'
        WHERE user_email = 'john@email.com' AND creation_date = '2021-03-14 16:10:19.622+0000';

    2 new rows appear in our table:

    cqlsh>    
        SELECT * FROM learn_cassandra.todo_by_user_email WHERE user_email='john@email.com';                                                                                                            

    user_email     | creation_date                   | name
   ----------------+---------------------------------+--------------
    john@email.com | 2021-03-14 16:10:19.622000+0000 | Update query
    john@email.com | 2021-03-14 16:07:19.622000+0000 | Insert query

    (2 rows)

    So you inserted a row using an update, and you can also use an insert to update:

    cqlsh>       
        INSERT INTO learn_cassandra.todo_by_user_email (user_email,creation_date,name) 
        VALUES('john@email.com', '2021-03-14 16:07:19.622+0000', 'Insert query updated');

    Let’s check our updated row:

    cqlsh>   
        SELECT * FROM learn_cassandra.todo_by_user_email WHERE user_email='john@email.com';

    user_email     | creation_date            | name
    ----------------+--------------------------+----------------------
    john@email.com | 2021-03-14 16:10:19.62   |         Update query
    john@email.com | 2021-03-14 16:07:19.62   | Insert query updated


    (2 rows)

    So UPDATE and INSERT are technically the same. 
    Don’t think that an INSERT fails if there is already a row with the same primary key.

    The same applies to an UPDATE — it will be executed, even if the row doesn’t exist.

    The reason for this is because, by design, Cassandra rarely reads before writing to keep performance high. 
    The only exceptions are described in the next section about lightweight transactions.

    But, there are restrictions what actions you can execute based on an update or insert:

    * Counters can only be changed with UPDATE, not with Insert
    * IF NOT EXISTS can only be used in combination with an INSERT
    * IF EXISTS can only be used in combination with an UPDATE


Lightweight Transactions
    You can use conditions in queries using a feature called lightweight transactions (LWTs), 
    which execute a read to check a certain condition before executing the write.

    Let’s only update if an entry already exists, by using IF EXISTS:

    cqlsh>     
        UPDATE learn_cassandra.todo_by_user_email 
        SET name = 'Update query with LWT'
        WHERE user_email = 'john@email.com' AND creation_date = '2021-03-14 16:07:19.622+0000' IF EXISTS;

    [applied]
    -----------
      True

    The same works for an insert query using IF NOT EXISTS:

    cqlsh>      
        INSERT INTO learn_cassandra.todo_by_user_email (user_email,creation_date,name) 
        VALUES('john@email.com', toTimestamp(now()), 'Yet another entry') IF NOT EXISTS;

    [applied]
    -----------
      True
    
    Those executions are expensive compared to simple UPDATE and INSERT queries. 
    Still, if it’s business-critical, they are an excellent way to achieve transactional safety.



    Cassandra is an excellent choice when you’re dealing with data that 
    doesn’t change (immutable data), and where updates and deletes are rare. 
    This means that Cassandra is great for handling huge volumes of immutable data 
    from personalization, fraud detection, time series, and sensor data.
    Cassandra is also an appropriate choice if you’re primarily looking for a 
    database that performs fast writes.


Cassandra Tools
    Cassandra offers several useful administration tools to monitor and manage your clusters. 
    The following is a brief description of the key tools you’ll often use.
    
        The cassandra Utility: 
            The cassandra utility enables you to start a Cassandra instance. 
            In addition, the utility enables you to perform other tasks, such as 
            replacing a dead node.

        The SSTable Utilities: 
            Cassandra offers about a dozen useful utilities that enable you to 
            perform SSTable tasks such as dumping the contents of a table, 
            printing a table’s metadata, splitting a table into multiple tables, 
            and listing the SSTable files for a table.

        The nodetool utility: 
            The nodetool utility is a command line tool to monitor and manage a cluster. 
            You’ll start using nodetool in Chapter 2, and by the time you reach the end 
            of the book, you’ll have learned every single nodetool command option.

        The cassandra-stress tool: 
            This is a stress testing utility you can use to benchmark and load test 
            your clusters. The tool is especially useful in understanding the scalability 
            of your database and optimizing your data models.

https://dsysd-dev.medium.com/why-apache-cassandra-is-a-killer-database-and-why-you-should-use-it-for-your-next-project-ff9017175f74