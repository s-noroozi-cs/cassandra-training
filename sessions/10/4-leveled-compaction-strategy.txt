$ docker run --rm -it --name cassandra cassandra:5.0.3

$ docker exec -it cassandra cqlsh

cqlsh> CREATE KEYSPACE lcs_demo WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};

cqlsh> USE lcs_demo ;

cqlsh:lcs_demo> CREATE TABLE user_actions (
    user_id text,
    action_time timestamp,
    action_type text,
    details text,
    PRIMARY KEY (user_id, action_time)
) WITH compaction = {
    'class': 'LeveledCompactionStrategy',
    'sstable_size_in_mb': 1  -- Very small for testing
};

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) 
VALUES ('user1', '2024-01-15 10:00:00', 'login', 'initial login');

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) 
VALUES ('user1', '2024-01-15 10:05:00', 'browse', 'viewing products');

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) 
VALUES ('user2', '2024-01-15 10:10:00', 'login', 'user2 login');

$ nodetool flush lcs_demo user_actions;

$ nodetool tablestats lcs_demo.user_actions | grep -E "Level|SSTable"

$ nodetool compact lcs_demo user_actions;

$ nodetool tablestats lcs_demo.user_actions | grep -E "Level|SSTable"

$ ls -lht /var/lib/cassandra/data/lcs_demo/user_actions***



cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) 
VALUES ('user3', '2024-01-15 10:15:00', 'login', 'user3 login');

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) 
VALUES ('user1', '2024-01-15 10:20:00', 'purchase', 'bought item A');

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) 
VALUES ('user4', '2024-01-15 10:25:00', 'login', 'user4 login');

$ nodetool flush lcs_demo user_actions;

$ nodetool compact lcs_demo user_actions;

$ nodetool tablestats lcs_demo.user_actions | grep -E "Level|SSTable"

cqlsh:lcs_demo> UPDATE user_actions SET details = 'updated login' 
WHERE user_id = 'user1' AND action_time = '2024-01-15 10:00:00';

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) 
VALUES ('user1', '2024-01-15 10:30:00', 'logout', 'user1 logout');

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) 
VALUES ('user2', '2024-01-15 10:35:00', 'purchase', 'user2 purchase');

$ nodetool flush lcs_demo user_actions;

$ nodetool tablestats lcs_demo.user_actions | grep -E "Level|SSTable"

$ nodetool compact lcs_demo user_actions;

$ nodetool tablestats lcs_demo.user_actions | grep -E "Level|SSTable"

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) VALUES ('user5', '2024-01-15 11:00:00', 'login', 'user5');

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) VALUES ('user6', '2024-01-15 11:05:00', 'login', 'user6');

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) VALUES ('user7', '2024-01-15 11:10:00', 'login', 'user7');

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) VALUES ('user8', '2024-01-15 11:15:00', 'login', 'user8');

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) VALUES ('user9', '2024-01-15 11:20:00', 'login', 'user9');

cqlsh:lcs_demo> INSERT INTO user_actions (user_id, action_time, action_type, details) VALUES ('user10', '2024-01-15 11:25:00', 'login', 'user10');

$ nodetool flush lcs_demo user_actions;

$ nodetool compact lcs_demo user_actions;

$ nodetool tablestats lcs_demo.user_actions | grep -E "Level|SSTable"

$ nodetool compactionhistory

What to Look For:
    Level 0: Where new SSTables appear first

    Level 1: SSTables move here after compacting with L0

    Higher Levels: Each level is 10x larger than previous

    SSTable Count: Fewer but larger SSTables in higher levels

    Space Usage: How data distributes across levels

Key Benefits You'll Observe:
    Read Efficiency: Fewer SSTables to check for queries

    Predictable Performance: Consistent read latency

    Space Management: Efficient disk usage

    Automatic Organization: Data sorted into levels automatically